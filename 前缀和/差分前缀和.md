# 差分前缀和
所谓**差分前缀和**就是每个位置的值不再是该位置之前所有元素的累加和(非前缀和)，而是**相邻两个元素之间的差**

**例如：**

原数组a[]：```1,5,2,11,7,14,3```

原差分前缀和：```1 4 -3 9 -4 7 -11```

现对某一个区间 ```[L,R]```中的值均进行相同的修改

**例：**

对原数组```[2,5]```之间的数都+3

现数组a[]：```1,8,5,14,10,14,3```

现差分前缀和：```1 7 -3 9 -4 4 -11```

**你会发现：**
+ 在a[L]的位置差分前缀和为原差分前缀和+3 
+ 在a[R+1]的位置差分前缀和为原差分前缀和-3

**差分前缀和的性质：差分前缀和(每个位置的值为该位置之前所有元素的累加和)——> 原数组 ——> 前缀和**

利用此差分前缀和可以解决经典题目:**校门外的树**<https://www.luogu.com.cn/problem/P1047>

### 解题思路

**> 1. 将原数组```a[L]```长度为L+1的数组中的值均设为1**
> + 1就表示该位置有树
> + 如果该位置的值不为1，则说明该位置没有树

**例如:**

原数组a[]：```1 1 1 1 1 1 1 1 1```

差分前缀和b[]：```1 0 0 0 0 0 0 0 0```

```
若要将区间[2,5]之间的树挖去

即对原数组```[2,5]```之间的数都-1

则将差分前缀和
+ b[2]-1
+ b[6]+1

则现差分前缀和：1 0 -1 0 0 0 1 0 0

则现原数组：1 1 0 0 0 0 1 1 1

即将区间[2,5]之间的树挖去了

若还要将区间[3,6]之间的树挖去

即对原数组```[3,6]```之间的数都-1

则将差分前缀和
+ b[3]-1
+ b[7]+1

则现差分前缀和：1 0 -1 -1 0 0 1 1 0

则现原数组：1 1 0 -1 -1 -1 0 1 1

即将区间[2,6]之间的树都挖去了
```

**然后对数组进行遍历**
+ 若值为1的即树存在，返回最后结果即可
+ 小于1的就为没有树

## 校门外的树
### 代码示例
```c
#include <iostream>
#include <bits/stdc++.h> 

using namespace std;

typedef long long ll;

ll i,k,l,m,u,v,cnt=0;
ll a[1000005],b[1000005];

int main(int argc, char** argv) {
	cin >> l >> m;
	for(i=0;i<=l;i++){
		a[i]=1;
	}
	b[0]=1;
	for(i=1;i<=l;i++){
		b[i]=a[i]-a[i-1];
	}
	for(k=0;k<m;k++){
		cin >> u >> v;
		b[u]-=1;
		b[v+1]+=1;
	}
	for(i=1;i<=l;i++){
		b[i]=b[i-1]+b[i];
	}
	for(i=0;i<=l;i++){
		if(b[i]==1){
			cnt++;
		}
	}
	cout<< cnt;
	return 0;
}
```
