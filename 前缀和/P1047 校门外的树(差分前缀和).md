# P1047 校门外的树
## 题目描述
某校大门外长度为 ***l*** 的马路上有一排树，每两棵相邻的树之间的间隔都是 ***1*** 米。我们可以把马路看成一个数轴，马路的一端在数轴 ***0*** 的位置，另一端在 ***l*** 的位置；数轴上的每个整数点，即 ```0,1,2,…,l```，都种有一棵树。

由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。

## 输入格式
第一行有两个整数，分别表示马路的长度 ***l*** 和区域的数目 ***m***。

接下来 ***m*** 行，每行两个整数 ***u***,***v***，表示一个区域的起始点和终止点的坐标。

## 输出格式
输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。

## 输入输出样例
### 输入 1 
```
500 3
150 300
100 200
470 471
```
### 输出 1 
```
298
```
### 说明/提示
### 数据规模与约定
+ 对于 20% 的数据，保证区域之间没有重合的部分。
+ 对于 100% 的数据，保证 1≤***l***≤10^4,1≤***m***≤100,0≤***u***≤***v***≤l

## 解题思路

**> 1. 将原数组```a[L]```长度为L+1的数组中的值均设为1**
> + 1就表示该位置有树
> + 如果该位置的值不为1，则说明该位置没有树
**例如:**

原数组a[]：```1 1 1 1 1 1 1 1 1```

差分前缀和b[]：```1 0 0 0 0 0 0 0 0```

```
若要将区间[2,5]之间的树挖去

即对原数组```[2,5]```之间的数都-1

则将差分前缀和

+ b[2]-1
+ b[6]+1

则现差分前缀和：1 0 -1 0 0 0 1 0 0

则现原数组：1 1 0 0 0 0 1 1 1

即将区间[2,5]之间的树挖去了

若还要将区间[3,6]之间的树挖去

即对原数组```[3,6]```之间的数都-1

则将差分前缀和

+ b[3]-1
+ b[7]+1

则现差分前缀和：1 0 -1 -1 0 0 1 1 0

则现原数组：1 1 0 -1 -1 -1 0 1 1

即将区间[2,6]之间的树都挖去了
```

**然后对数组进行遍历**
+ 若值为1的即树存在，返回最后结果即可
+ 小于1的就为没有树

## 代码示例
```c
#include <iostream>
#include <bits/stdc++.h> 
using namespace std;
typedef long long ll;
ll i,k,l,m,u,v,cnt=0;
ll a[1000005],b[1000005];
int main(int argc, char** argv) {
	cin >> l >> m;
	for(i=0;i<=l;i++){
		a[i]=1;
	}
	b[0]=1;
	for(i=1;i<=l;i++){
		b[i]=a[i]-a[i-1];
	}
	for(k=0;k<m;k++){
		cin >> u >> v;
		b[u]-=1;
		b[v+1]+=1;
	}
	for(i=1;i<=l;i++){
		b[i]=b[i-1]+b[i];
	}
	for(i=0;i<=l;i++){
		if(b[i]==1){
			cnt++;
		}
	}
	cout<< cnt;
	return 0;
}
```
