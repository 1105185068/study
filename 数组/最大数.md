# 最大数
## 问题描述
给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。

**示例 1:**
```
输入: [10,2]
输出: 210
```
**示例 2:**
```
输入: [3,30,34,5,9]
输出: 9534330
```
**说明:** 输出结果可能非常大，所以你需要返回一个字符串而不是整数。

## 问题分析
### 自定义排序：
**想法**

为了构建最大数字，我们希望越高位的数字越大越好。

**算法**

首先，我们将每个整数变成字符串。然后进行排序。

如果仅按降序排序，有相同的开头数字的时候会出现问题。比方说，样例 2 按降序排序得到的数字是 95343303 ，然而交换 3 和 30 的位置可以得到正确答案 9534330 。因此，每一对数在排序的比较过程中，我们比较两种连接顺序哪一种更好。我们可以证明这样的做法是正确的：

假设（不是一般性），某一对整数 a 和 b ，我们的比较结果是 a 应该在 b 前面，这意味着 a⌢b>b⌢a ，其中 ⌢ 表示连接。如果排序结果是错的，说明存在一个 c ， b 在 c 前面且 c 在 a 的前面。这产生了矛盾，因为 a⌢b>b⌢a 和 b⌢c>c⌢b 意味着 a⌢c>c⌢a 。换言之，我们的自定义比较方法保证了传递性，所以这样子排序是对的。

一旦数组排好了序，最“重要”的数字会在最前面。有一个需要注意的情况是如果数组只包含 0 ，我们直接返回结果 0 即可。否则，我们用排好序的数组形成一个字符串并返回。

## Python 代码示例
```python
class LargerNumKey(str):
    def __lt__(x, y):
        return x+y > y+x
        
class Solution:
    def largestNumber(self, nums):
        largest_num = ''.join(sorted(map(str, nums), key=LargerNumKey))
        return '0' if largest_num[0] == '0' else largest_num
```
## 解释说明

自定义LargerNumKey类中使用了python自带的 __lt__ 方法，用来比较大小，一般用于小于号

+ （类中的特殊方法 __lt__(self,other) 当使用 小于 运算符（<）的时候调用。类似地，对于所有的运算符（+，>等等）都有特殊的方法。）

Python 富比较方法: <https://blog.csdn.net/LaoYuanPython/article/details/95042104?utm_source=app>

返回值为 bool 类型，即 bool值，也可以是任意值。

### 举例说明：
如比较字符串 '3' 和 '30' 时，即 '330' > '303' ,返回 True ,即 sorted() 对其列表```nums```进行排序，即字符串 '3' 排在 '30' 前面，再比较字符串 '34' 和 '30' ,即 '3430' > '3034' ，返回 True , sorted() 对其列表```nums```进行排序，即字符串 '34' 排在 '30' 前面,这时，字符串 '34' 和字符串 '3' 均排在字符串 '30' 前面，
这时，将会比较字符串 '34' 和 '3' 的大小，经比较，字符串 '343' > '334' ,即 '34' 排在 '3' 前面，就形成了字符串 '34330' ，以此类推，用该__lt__(self,other)方法继续比较字符串 '5' 和字符串 '9' 然后得到最终排序结果字符串'9534330'

## 复杂度分析

+ 时间复杂度：O(nlgn)

尽管我们在比较函数中做了一些额外的工作，但是这只是一个常数因子。所以总的时间复杂度是由排序决定的，在 Python 和 Java 中都是 O(nlgn) 。

+ 空间复杂度：O(n)

这里，我们使用了 O(n) 的额外空间去保存 ```nums``` 的副本。尽管我们就地进行了一些额外的工作，但最后返回的数组需要 O(n) 的空间。因此，需要的额外空间与 ```nums``` 大小成线性关系。
