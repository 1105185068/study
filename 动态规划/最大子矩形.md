# 最大子矩形
## 题目描述
为了更好的备战NOIP2013，电脑组的几个女孩子LYQ,ZSC,ZHQ认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。

校长先给他们一个***N*N***矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于```[-127,127]```,例如
```
 0 –2 –7  0 
 9  2 –6  2
-4  1 –4  1 
-1  8  0 –2
```
在左下角：
```
9  2
-4  1
-1  8
```
**和为15**

几个女孩子有点犯难了，于是就找到了电脑组精打细算的HZH，TZY小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？

### 输入格式
第一行：n，接下来是n行n列的矩阵。

### 输出格式
最大矩形（子矩阵）的和。

### 输入输出样例
#### 输入 1
```
4
0 -2 -7 0
 9 2 -6 2
-4 1 -4  1 
-1 8  0 -2
```
#### 输出 1
```
15
```
### 说明/提示
n<=120

### 解题思路
该题算是P1115 最大子段和的一个升级版，其实思想差不多，都是DP，只不过该题需要先进行一个矩阵压缩，即二维变一维。

矩阵压缩：

假设有一个矩阵：
```
-5 6 4

1 -2 6

2 1 -3
```
如何对它进行压缩呢，其实不难，这边我做一个类比，如果我们把一行看做一个数，这里看做三个数a,b,c,那么将这三个相邻数的进行不同的组合，将这个新的组合视为一个新的数，这就是进行压缩处理，例如a,b,c可以组合为{[a],[ab],[abc],[b],[bc],[c]}，而矩阵压缩也类似。

先设置一个变量max用于保存压缩后的一维数组的最大子序列和。

第一次我们取第一行：

-5 6 4

则其最大子序列和为10，max=10。

第二次取第一二行：

-5 6 4

1 -2 6

注意现在开始是矩阵压缩的精髓，我们将每一列的数进行相加，将多行变为一行。

第一列：-5+1=-4

第二列：6+(-2)=4

第三列：4+6=10

所以压缩后的一维数组为：

-4 4 10

则其最大子序列和为14，max=14。

第三次取第一二三行：

-5 6 4

1 -2 6

2 1 -3

对每一列进行压缩：

第一列：-5+1+2=-2

第二列：6+(-2)+1=5

第三列：4+6+(-3)=7

所以压缩后的一维数组为：

-2 5 7

则其最大子序列和为12，max=14。

第四次取第二行：

1 -2 6

则其最大子序列和为6，max=14。

第五次取第二三行：

1 -2 6

2 1 -3

对每一列进行压缩：

第一列：1+2=3

第二列：-2+1=-1

第三列：6+(-3)=3

所以压缩后的一维数组为：

3 -1 3

则其最大子序列和为5，max=14。

第六次取第三行：

2 1 -3

则其最大子序列和为3，max=14。

最后求得这个矩阵最大的子矩阵和为14

也就是第一二行的三四列

6 4

-2 6

### 代码示例
```c
#include <bits/stdc++.h>

#define infinitesimal  -2100000000

using namespace std;

typedef long long int lli;

#define maxn 150
#define maxm 20
int n, m, t;
int matrix[maxn][maxn];
int ans = infinitesimal;
int temp[maxn];
int dp[maxn];

void Arrsum() {
	//每次执行该语句定义一个新数组，将原数组清空，并将上一次数组的长度赋给新数组
    memset(dp,0,sizeof(dp));
    for(int i=1;i<=n;i++){
    	//动态规划，求一个一维线性数组中最大子序列
        dp[i] = max(temp[i], dp[i - 1] + temp[i]);
        ans = max(ans, dp[i]);
    }
}

void MatrixSum(){
	//最大4行 3行 2行 1行，将所有情况循环枚举 
    for(int i=1;i<=n;i++){
    	//每次执行该语句定义一个新数组，将原数组清空，并将上一次数组的长度赋给新数组
        memset(temp,0,sizeof(temp));
        for(int j=i;j<=n;j++){
            for(int k=1;k<=n;k++){
            	//j=1时，temp[1]记录第一列的第一个数，temp[2]记录第二列的第一个数，temp[3]记录第三列的第一个数，temp[4]记录第一列的第一个数
            	//然后j=2时，每一竖行上下相加，即temp[1]记=m[1][1]+m[2][1]
                temp[k] += matrix[j][k];
            }
            Arrsum();
        }
    }
}

int main() {
    scanf("%d", &n);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            scanf("%d", &matrix[i][j]);
        }
    }
    MatrixSum();
    printf("%d\n", ans);
    return 0;
}
```
