# 打家劫舍
## 打家劫舍I
### 问题描述
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。**

给定一个代表每个房屋存放金额的非负整数数组，计算你**不触动警报装置的情况下**，一夜之内能够偷窃到的最高金额。

**示例 1**：
```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
**示例 2**：
```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```
### 问题分析
如果你对于动态规划还不是很了解，或者没怎么做过动态规划的题目的话，那么 House Robber （小偷问题）这道题是一个非常好的入门题目。本文会以 House Robber 题目为例子，讲解动态规划题目的四个基本步骤。

动态规划的的四个解题步骤是：

+ 定义子问题
+ 写出子问题的递推关系
+ 确定 DP 数组的计算顺序
+ 空间优化（可选）
下面我们一步一步地进行讲解。

**步骤一：定义子问题**

稍微接触过一点动态规划的朋友都知道动态规划有一个“子问题”的定义。什么是子问题？子问题是和原问题相似，但规模较小的问题。例如这道小偷问题，原问题是“从全部房子中能偷到的最大金额”，将问题的规模缩小，子问题就是“从 k 个房子中能偷到的最大金额”，用 f(k) 表示。

可以看到，子问题是参数化的，我们定义的子问题中有参数 k。假设一共有 n 个房子的话，就一共有 n 个子问题。动态规划实际上就是通过求这一堆子问题的解，来求出原问题的解。这要求子问题需要具备两个性质：

+ 原问题要能由子问题表示。例如这道小偷问题中，k=n 时实际上就是原问题。否则，解了半天子问题还是解不出原问题，那子问题岂不是白解了。
+ 一个子问题的解要能通过其他子问题的解求出。例如这道小偷问题中，f(k) 可以由 f(k-1) 和 f(k-2) 求出，具体原理后面会解释。这个性质就是教科书中所说的“最优子结构”。如果定义不出这样的子问题，那么这道题实际上没法用动态规划解。

小偷问题由于比较简单，定义子问题实际上是很直观的。一些比较难的动态规划题目可能需要一些定义子问题的技巧。

**步骤二：写出子问题的递推关系**

这一步是求解动态规划问题最关键的一步。然而，这一步也是最无法在代码中体现出来的一步。在做题的时候，最好把这一步的思路用注释的形式写下来。做动态规划题目不要求快，而要确保无误。否则，写代码五分钟，找 bug 半小时，岂不美哉？

我们来分析一下这道小偷问题的递推关系：

假设一共有 n 个房子，每个房子的金额分别是H0,H1,···,Hn-1 ，子问题 f(k)表示从前 k 个房子（即 H0,H1,···,Hk-1)中能偷到的最大金额。那么，偷 k 个房子有两种偷法：
 1. 偷前k-1间房子，最后一间不偷（即f（k-1））
 2. 偷前k-2间房子和最后一间（即f(k-2)+Hk-1）

k 个房子中最后一个房子是Hk-1。如果不偷这个房子，那么问题就变成在前 k-1 个房子中偷到最大的金额，也就是子问题 f(k-1)。如果偷这个房子，那么前一个房子 Hk-2 显然不能偷，其他房子不受影响。那么问题就变成在前 k-2 个房子中偷到的最大的金额。两种情况中，选择金额较大的一种结果。

f(k)=max{f(k−1),H 
k−1
​	
 +f(k−2)}
 
在写递推关系的时候，要注意写上 k=0 和 k=1 的基本情况：

+ 当 k=0 时，没有房子，所以 f(0) = 0。
+ 当 k=1 时，只有一个房子，偷这个房子即可，所以 f(1)=H 
0
​	
 。
 
这样才能构成完整的递推关系，后面写代码也不容易在边界条件上出错。
### 解题思路
**抓住偷与不偷最后一间房子的两种状态，即得状态转移方程**

**偷 k 个房子有两种偷法：**
 1. 偷前k-1间房子，最后一间不偷（即f（k-1））
 2. 偷前k-2间房子和最后一间（即f(k-2)+Hk-1）

**状态转移方程：**

 f(k)=max{f(k−1),H 
k−1
​	
 +f(k−2)}
 
 ### 代码示例
 ```python
 class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums)==0:
            return 0;
        N=len(nums)
        dp=[0]*(N+1)
        dp[0]=0
        dp[1]=nums[0]
        for i in range(2,N+1):
            dp[i]=max(dp[i-1],dp[i-2]+nums[i-1])
        return dp[N]
 ```
