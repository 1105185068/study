# 有效的数独
## 问题描述
判断一个 ```9x9``` 的数独是否有效。**只需要根据以下规则**，验证已经填入的数字是否有效即可。

数字 ```1-9``` 在每一行只能出现一次。
数字 ```1-9``` 在每一列只能出现一次。
数字 ```1-9``` 在每一个以粗实线分隔的 ```3x3``` 宫内只能出现一次。

|5|3|||7|||||
|-|-|-|-|-|-|-|-|-|
|6|||1|9|5||||
||9|8|||||6||
|8||||6||||3|
|4|||8||3|||1|
|7||||2||||6|
||6|||||2|8||
||||4|1|9|||5|
|||||8|||7|9|

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 ```'.'``` 表示。

**示例 1:**
```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

**示例 2:**
```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```
**说明:**

+ 一个有效的数独（部分已被填充）不一定是可解的。
+ 只需要根据以上规则，验证已经填入的数字是否有效即可。
+ 给定数独序列只包含数字 ```1-9``` 和字符 ```'.'``` 。
+ 给定数独永远是 ```9x9``` 形式的。

## 暴力法
**双层循环遍历数独表中所有元素，并将其存储到set()集合中和list()列表中，通过判断集合和列表长度是否相同来判断是否有重复元素**

## 代码示例
```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        nums = {"1", "2", "3", "4", "5", "6", "7", "8", "9"}
        #存储9行中每行出现的元素，运行结果：
        #[set(), set(), set(), set(), set(), set(), set(), set(), set()]
        row = [set() for _ in range(9)]
        #存储9行中每行出现的元素，运行结果：
        #[set(), set(), set(), set(), set(), set(), set(), set(), set()]
        col = [set() for _ in range(9)]
        #存储9个小九宫格出现的元素，运行结果：
        #[[set(), set(), set()], [set(), set(), set()], [set(), set(), set()]]
        palace = [[set() for _ in range(3)] for _ in range(3)]  # 3*3
        #存储空格
        blank = []
        for i in range(9):
            for j in range(9):
                ch = board[i][j]
                if ch == ".":
                    blank.append((i, j))
                else:
                    #记录每行出现的元素
                    row[i].add(ch)
                    #记录每列出现的元素
                    col[j].add(ch)
                    #记录所有9个九宫格中每个九宫格已经出现的元素
                    palace[i//3][j//3].add(ch)
        
        #存储9行中每行出现的元素，运行结果：
        #[set(), set(), set(), set(), set(), set(), set(), set(), set()]
        row2 = [[] for _ in range(9)]
        #存储9行中每行出现的元素，运行结果：
        #[set(), set(), set(), set(), set(), set(), set(), set(), set()]
        col2 = [[] for _ in range(9)]
        #存储9个小九宫格出现的元素，运行结果：
        #[[set(), set(), set()], [set(), set(), set()], [set(), set(), set()]]
        palace2 = [[[] for _ in range(3)] for _ in range(3)]  # 3*3
        #存储空格
        blank2 = []
        for i in range(9):
            for j in range(9):
                ch = board[i][j]
                if ch == ".":
                    blank2.append((i, j))
                else:
                    #记录每行出现的元素
                    row2[i].append(ch)
                    #记录每列出现的元素
                    col2[j].append(ch)
                    #记录所有9个九宫格中每个九宫格已经出现的元素
                    palace2[i//3][j//3].append(ch)
        for i in range(9):
            if len(row[i])!=len(row2[i]) or len(col[i])!=len(col2[i]):
                return False
        for i in range(3):
            for j in range(3):
                if len(palace[i][j])!=len(palace2[i][j]):
                    return False
        return True
```
